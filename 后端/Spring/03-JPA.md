# JPA

JPA 即 Java 持久化 API（Java Persistence API），是一个用于映射 Java 对象和关系型数据库表的规范。此规范使得开发者可以不依赖特定数据库，也能很好地 CRUD（创建、读取、更新、删除）。

JPA 的三个组件：

- **实体（Entities）**：实体是普通 Java 对象（POJO）。
- **对象-关系型元数据（Object-relational metadata）**：开发者需要设定 Java 类和它们的属性与数据库中的表和列的映射关系。有两种设定方式：通过特定的配置文件建立映射；或者使用注解。
- **Java 持久化查询语句（Java Persistence Query Language - JPQL）**：JPA 旨在建立不依赖于特定的数据库的抽象层，所以它提供了一种专有查询语言来代替 SQL，即 JPQL。它提供了支持不同数据库方言的特性，使开发者实现查询逻辑时不需要考虑特定的数据库类型。

## 序列（Sequences）

注解 `@GeneratedValue` 可以设置这个唯一值将会如何分配给每个实体。JPA 提供了如下三种不同的方法：

- **TABLE**：这种策略会创建一个单独的表，其中为每个实体保存一条记录。这条记录包含实体的名字和 id 列的当前值；每次有新的 id 值请求时，就更新此表中相应的行。
- **SEQUENCE**：如果数据库支持**序列**的话，这个策略可以通过数据库序列获得唯一值。
- **IDENTITY**：如果数据库支持**标识列**的话，这个策略就可以使用这种数据库原生支持的列。

TABLE 策略需要提供用来做序列管理的表的具体信息给 JPA 提供商：

```java
@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "TABLE_GENERATOR")
@TableGenerator(name = "TABLE_GENERATOR", table="T_SEQUENCES", pkColumnName = "SEQ_NAME", valueColumnName = "SEQ_VALUE", pkColumnValue = "PHONE")
public Long getId() {
    return id;
}
```

注解 @TableGenerator 告诉 JPA 提供商这里设定的表名为 T_SEQUENCES、有两个列 SEQ_NAME 和 SEQ_VALUE。这个表中的这个序列的名字是 PHONE：

```bash
sql> select * from t_sequences;
SEQ_NAME | SEQ_VALUE
PHONE    | 1
```

SEQUENCE 策略使用：

```java
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "S_PROJECT")
@SequenceGenerator(name = "S_PROJECT", sequenceName = "S_PROJECT", allocationSize = 100)
public Long getId() {
    return id;
}
```

使用注解 @SequenceGenerator，告诉 JPA 提供商使用到的序列名是 S_PROJECT，指定了分配大小（这里是 100），即有多少值应预先分配。属性 generator 和 name 用来关联这两个注解。这个策略使用的是一个单独的表，当系统中有大量序列值请求时，它很容易成为性能瓶颈，因此 JPA 支持预定义大小，以使不用频繁请求数据库。

DENTITY 策略，只需设置相应的 strategy 属性：

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
public Long getId() {
    return id;
}
```

如果当前数据库支持**标识列**的话，对应的表就会创建如下：

```sql
create table T_ID_CARD (
    id bigint generated by default as identity,
    ID_NUMBER varchar(255),
    ISSUE_DATE timestamp,
    VALID integer,
    primary key (id)
)
```
