ES6 对语法进行了大量扩展，包括且不限于字符串、正则、数值、函数、数组、对象的扩展等，此篇总结 ES6 新增的一些常用的新语法，一起来学习新姿势。<!-- more -->

### 字符串的扩展

ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。

#### Unicode 表示法

JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。但只限于码点在 `\u0000~\uFFFF` 之间的字符。对于 Unicode 码点大于 0xFFFF 的字符，需要 2 个字符，也就是 4 个字节存储。

同时如果在 \u 后面码点大于 0xFFFF，需要加上花括号才能正确显示，如 `\u{20BB7}`。

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```javascript
'z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### codePointAt() 和 fromCodePoint()

对于 4 个字节的字符，JavaScript 不能正确处理，字符串长度会被误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前 2 个字节和后 2 个字节的值。

ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

codePointAt 方法是测试一个字符是由 2 个字节还是 4 个字节组成的最简单方法。

```javascript
function is32Bit(c) {
  return c.codePointAt(0) > 0xffff
}
```

于此同时，ES6 提供了 String.fromCodePoint 方法，作用同 codePointAt 相反，新方法可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。

```javascript
String.fromCodePoint(0x20bb7)
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y' // true
```

上面的代码中，如果 String.fromCharCode 方法有多个参数，则它们会被合并成一个字符串返回。

注意：**fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。**

#### 遍历器接口

ES6 为字符串添加了遍历器接口，使得字符串可以由 for...of 循环遍历。同时，遍历器的最大优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。

#### at()

ES5 对字符串对象提供了 charAt 方法，返回字符串给定位置的字符。同样，该方法不能识别码点大于 0xFFFF 的字符。

ES6 有一个提案提出字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。

#### includes()、startsWith()、endsWidth()

ES6 新增 3 种新方法用来判断一个字符串是否包含在另一个字符串中。

- includes()：返回布尔值，表示是否找到了参数字符串。
- startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
- endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。

注意：**使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置到字符串结束位置之间的字符。**

#### repeat()

repeat 方法返回一个新字符串，表示将原字符串重复 n 次。如果 repeat 的参数是字符串，则会先转换成数字。

```javascript
'na'.repeat('3') // 'nanana'
```

#### padStart()、padEnd()

ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart() 用于头部补全，padEnd() 用于尾部补全。如果省略第二个参数，则会用空格来补全。

```javascript
'x'.padStart(5, 'ab') // 'ababx'
'x'.padEnd(5, 'ab') // 'xabab'

'x'.padStart(4) // '   x'
```

padStart 的常见用途是为数值补全指定位数和提示字符串格式。

```javascript
'1'.padStart(10, '0') // '0000000001'
'09-12'.padStart(10, 'YYYY-MM-DD') // 'YYYY-09-12'
```

#### 标签模板

模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。

标签模板其实不是模板，而是函数调用的一种特殊形式。整个表达式的返回值就是函数处理模板字符串后的返回值。

```javascript
var a = 5
var b = 10
tag`Hello ${a + b} world ${a * b}`
// 等同于tag(['Hello ', ' world ', ''], 15, 50);
```

标签函数的第一个参数是数组，数组成员是模板字符串中那些没有变量替换的部分，变量替换只发生在数组的成员之间。

### 正则的扩展

#### 修饰符与属性

ES6 为正则添加了新的修饰符：u 修饰符、y 修饰符、s 修饰符和 sticky 属性、flags 属性。关于这部分内容，等深入学习正则时再做总结。

#### 后行断言

JavaScript 语言的正则表达式只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。目前，有一个引入后行断言提案被提出，其中 V8 引擎已经支持。

“先行断言”指的是，x 只有在 y 前面才匹配，必须写成 `/x(?=y)/` 的形式。比如，只匹配百分号之前的数字，要写成 `/\d+(?=%)/`。“先行否定断言”指的是，x 只有不在 y 前面才匹配，必须写成 `/x(?!y)/` 的形式。比如，只匹配不在百分号之前的数字，要写成 `/\d+(?!%)/`。

```javascript
;/\d+(?=%)/.exec('100% of US presidents have been male') // ["100"]
;/\d+(?!%)/.exec('that’s all 44 of them') // ["44"]
```

“后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成 `/(?<=y)x/` 的形式，比如，只匹配美元符号之后的数字，要写成 `/(?<=\$)\d+/`。“后行否定断言”则与“先行否定断言”相反，x 只有不在 y 后面才匹配，必须写成 `/(?<!y)x/` 的形式。比如，只匹配不在美元符号后面的数字，要写成 `/(?<!\$)\d+/`。

```javascript
;/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') // ["100"]
;/(?<!\$)\d+/.exec('it’s is worth about €90') // ["90"]
```

“先行断言”和“后行断言”中括号部分都是不计入返回结果的：

```javascript
const RE_DOLLAR_PREFIX = /(?<=\$)foo/g
'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar') // '$bar %foo foo'
```

“后行断言”的实现需要先匹配 `/(?<=y)x/` 的 x，然后再回到左边匹配 y 的部分。这种“先右后左”的执行顺序与所有其他正则操作相反，导致了一些不符合预期的结果。

```javascript
;/(?<=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]
;/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]
```

其次，“后行断言”的反斜杠引用也与通常的顺序相反，必须放在对应的括号之前。

```javascript
;/(?<=(o)d\1)r/.exec('hodor') // null
;/(?<=\1d(o))r/.exec('hodor') // ["r", "o"]
// 完整输出：["r", "o", index: 4, input: "hodor"]
```

上面的代码中，后行断言的反斜杠引用（\1）必须放在前面才可以，放在括号的后面就不会得到匹配结果。因为后行断言是先从左到右扫描，发现匹配以后再回过头从右到左完成反斜杠引用。

#### 扩展

exec() 方法用于检索字符串中的正则表达式的匹配。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。

除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。

如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。

在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。

但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。

### 数值的扩展

#### 二进制与八进制表示法

ES6 提供了二进制和八进制数值的新写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。

如果要将使用 0b 和 0x 前缀的字符串数值转为十进制数值，要使用 Number 方法。

```javascript
Number('0b111') // 7
Number('0o10') // 8
```

#### Number.isFinite()、Number.isNaN()

ES6 在 Number 对象上新提供了 Number.isFinite() 和 Number.isNaN() 两个方法。

Number.isFinite() 用来检查一个数值是否为有限的（finite）。

Number.isNaN() 用来检查一个值是否为 NaN。

这两个新方法与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值转为数值，再进行判断，而新方法只对数值有效，对于非数值一律返回 false。

这两个方法皆可在 ES5 中部署：

```javascript
;(function(global) {
  var global_isFinite = global.isFinite
  var global_isNaN = global.isNaN

  Object.defineProperty(Number, 'isFinite', {
    value: function isFinite(value) {
      return typeof value === 'number' && global_isFinite(value)
    },
    configurable: true,
    enumerable: false,
    writable: true
  })

  Object.defineProperty(Number, 'isNaN', {
    value: function isNaN(value) {
      return typeof value === 'number' && global_isNaN(value)
    },
    configurable: true,
    enumerable: false,
    writable: true
  })
})(this)
```

#### Number.parseInt()、Number.parseFloat()

ES6 将全局方法 parseInt() 和 parseFloat() 移植到了 Number 对象上面，行为完全保持不变。这样做的目的是逐步减少全局性方法，使得语言逐步模块化。

```javascript
Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
```

#### Number.isInteger()

Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。

```javascript
Number.isInteger(3.0) // true
```

ES5 可以通过下面的代码部署 Number.isInteger():

```javascript
;(function(global) {
  var floor = Math.floor,
    isFinite = global.isFinite
  Object.defineProperty(Number, 'isInteger', {
    value: function isInteger(value) {
      return (
        typeof value === 'number' && isFinite(value) && floor(value) === value
      )
    },
    configurable: true,
    enumerable: false,
    writable: true
  })
})(this)
```

#### Number.EPSILON

ES6 在 Number 对象上面新增一个极小的常量 `Number.EPSILON`，目的在于为浮点数计算设置一个误差范围。

但是计算误差能够小于 Number.EPSILON，就可以认为得到了正确结果。

```javascript
function withinErrorMargin(left, right) {
  return Math.abs(left - right) < Number.EPSILON
}
```

#### 安全整数和 Number.isSafeInteger()

JavaScript 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围就无法精确表示。

```javascript
Math.pow(2, 53) // 输出：9007199254740992
9007199254740993 // 输出：9007199254740992，超出范围不再精确
9007199254740993 === 9007199254740992 // true
```

ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 两个常量，用来表示这个范围的上下限。

```javascript
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true
```

Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内。

#### Math 对象的扩展

ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。

- Math.trunc 方法用于去除一个数的小数部分，返回整数部分。
- Math.sign 方法用来判断一个数到底是正数、负数，还是零。对于非数值，会先将其转换为数值。其返回值有 5 种情况。参数位正数返回 +1；参数为负数返回 -1；参数为 0 返回 0；参数为 -0 返回 -0；参数为其他值返回 NaN。
- Math.cbrt 方法用于计算一个数的立方根。
- JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。
- Math.imul 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。大多数情况下，Math.imul(a, b) 与 a\*b 的结果是相同的，即该方法等同于 (a\*b)|0 的效果（超过 32 位的部分溢出）。
- Math.fround 方法返回一个数的单精度浮点数形式。
- Math.hypot 方法返回所有参数的平方和的平方根。
- Math.expm1(x) 返回 e-1，即 Math.exp(x)-1。
- Math.log1p(x) 方法返回 ln(1+x)，即 Math.log(1+x)。如果 x 小于 -1，则返回 NaN。
- Math.log10(x) 返回以 10 为底的 x 的对数。如果 x 小于 0，则返回 NaN。
- Math.log2(x) 返回以 2 为底的 x 的对数。如果 x 小于 0，则返回 NaN。
- Math.sinh(x) 返回 x 的双曲正弦（hyperbolic sine）
- Math.cosh(x) 返回 x 的双曲余弦（hyperbolic cosine）
- Math.tanh(x) 返回 x 的双曲正切（hyperbolic tangent）
- Math.asinh(x) 返回 x 的反双曲正弦（inverse hyperbolic sine）
- Math.acosh(x) 返回 x 的反双曲余弦（inverse hyperbolic cosine）
- Math.atanh(x) 返回 x 的反双曲正切（inverse hyperbolic tangent）

#### 指数运算符

ES6 新增了一个指数运算符 `**`。指数运算符可以与等号结合，形成一个新的赋值运算符`**=`。

```javascript
let a = 2
a **= 3 // 8
```

### 函数的扩展

### 数组的扩展

### 对象的扩展
