## 02-19

### 0x01 Java 中的内部类

问：什么是内部类呢？  
答：内部类（Inner Class）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。

问：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！  
答：内部类的主要作用如下：

1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

问：内部类有几种呢？  
答：内部类可分为以下几种：

- 成员内部类
- 静态内部类
- 方法内部类
- 匿名内部类

### 0x02 解除 chrome 跨域限制

```bash
chrome.exe --user-data-dir="C:/Chrome dev session" --disable-web-security
```

### 0x03 VSCode 快捷键

|           Key            |   Desc   |
| :----------------------: | :------: |
|         Ctrl + D         | 多行选中 |
| (Ctrl + D) + (Ctrl + F2) | 选中替换 |
|     Ctrl + Shift + L     | 所有匹配 |
|         Ctrl + I         | 选择一行 |
|         Ctrl + G         | 跳转行数 |
|        Ctrl + \          | 新建面板 |
|        Ctrl + Tab        | 文件切换 |
|         Ctrl + H         | 查找替換 |
|       Ctrl + Enter       | 插入一行 |
|         Ctrl + B         | 关闭侧栏 |
|     Ctrl + Shift + M     | 显示错误 |
|     Ctrl + Shift + K     | 刪除一行 |
|         Alt + Up         | 上移一行 |
|     Alt + Shift + Up     | 复制一行 |
|     Alt + Shift + F      | 格式代码 |
| (Ctrl + K) + (Ctrl + S)  | 快捷目录 |

其它：

1. Ctrl+C Ctrl+X 如果不选中，默认复制或剪切一整行

## 02-20

### 0x01 Java 的抽象类

声明抽象方法会造成以下两个结果：

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

抽象类总结：

1. 抽象类不能被实例化，只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

### 0x02 Java 的接口

抽象类和接口的区别：

1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 `public static final` 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

接口的成员特点：

1. 成员变量只能是常量，默认修饰符 `public static final`
2. 员方法只能是抽象方法。默认修饰符 `public abstract`

### 0x03 Java 集合概念

![Java集合](https://i.loli.net/2019/02/20/5c6d16c8daa77.png)

### 0x03 Java Class 类

Java Class 类的两个概念：

1. Java 语言中，万事万物皆对象，但**普通数据类型和静态的成员**不是对象。
2. 类是对象，类是 `java.lang.Class` 类的实例对象。There is a class named Class。

任何一个类都是 Class 的实例对象，这个实例对象有三种表示方式。

```java
package com.chanshiyu;

public class Hello {
  public static void main(String[] args) {
    // Foo 的实例对象
    Foo foo1 = new Foo();

    // Foo 这个类也是 Class 的实例对象，有三种表示方式
    // 1. 第一种表示方式：任何一个类都有一个隐含的静态成员变量 class
    Class c1 = Foo.class;

    // 2.第二种表示方式：已知该类的实例对象，使用 getClass 方法
    Class c2 = foo1.getClass();

    // 3.第三种表示方式
    Class c3 = null;
    try {
      c3 = Class.forName("com.chanshiyu.Foo");
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    }

    // c1、c2、c3 代表了 Foo 类的类类型（class type）
    // c1 == c2 == c3，一个类只能 Class 类的一个实例对象
    // 可以通过 c1、c2、c3 来创建实例对象
    try {
      Foo foo2 = (Foo)c1.newInstance();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

class Foo {}
```

### 0x04 动态加载类

编译时刻加载类是静态加载类，运行时刻加载类是动态加载类。`Class.forName("类的全称")` 不仅代表了类类型（class type），还代表了动态加载类。

new 创建对象是静态加载类，在编译时刻就需要加载所有可能用到的类。通过动态加载类可以实现按需加载类。

```java
package com.chanshiyu;

public class Office {
  public static void main(String[] args) {
    try {
      // 动态加载类
      Class c = Class.forName(args[0]);
      // 通过类类型创建对象
      OfficeAble oa = (OfficeAble) c.newInstance();
      oa.start();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

class Word implements OfficeAble {
  @Override
  public void start() {
    System.out.println("wold start");
  }
}

interface OfficeAble {
  public void start();
}
```

## 02-21

### 0x01 获取类的信息

反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

获取类类型，再通过类类型获取类名称：

```java
Class c1 = int.class; // int 的类类型
Class c2 = String.class; // String 的类类型
Class c3 = void.class; // void 的类类型
System.out.println(c1.getName()); // int
System.out.println(c2.getName()); // java.lang.String
System.out.println(c2.getSimpleName()); // String
System.out.println(c3.getName()); // void
```

工具类获取类的信息：

```java
package com.chanshiyu;

import java.lang.reflect.Method;
import java.lang.reflect.Field;
import java.lang.reflect.Constructor;

public class ClassUtil {
  /**
   * 打印类的信息，包括成员变量与成员函数
   * @param obj 该对象所属类的信息
   */
  public static void printClassMessage(Object obj) {
    // 首先获取类类型
    Class c = obj.getClass();
    // 获取类的名称
    System.out.println("类的名称:" + c.getName());

    /**
     * Method 类，方法对象。一个成员方法就是一个 Method 对象
     * getMethods() 方法获取所有 public 方法，包括父类继承而来的
     * getDeclaredMethods() 方法获取该类自己申明的方法，不问访问权限
     */
    Method[] ms = c.getMethods();
    for (Method m: ms) {
      // 获取方法名
      System.out.print(m.getName());
      // 获取方法返回值类型
      Class returnType = m.getReturnType();
      System.out.print("方法返回值类型:" + returnType.getName());
      // 获取参数类型
      System.out.print("  参数类型：");
      Class[] paramTypes = m.getParameterTypes();
      for (Class c1: paramTypes) {
        System.out.print(c1.getName() + ",");
      }
      System.out.println();
    }

    /**
     * 获取成员变量：java.lang.reflect.Field
     * 成员变量也是对象，Field 类封装了成员变量的操作
     * getFileds() 方法获取所有 public 变量，包括父类继承而来的
     * getDeclaredFileds() 方法获取该类自己声明的变量，不问访问权限
     */
    Field[] fs = c.getDeclaredFields();
    for(Field field: fs) {
      // 获取成员变量的名称
      String fieldName = field.getName();
      // 获取成员变量类型
      Class fieldType = field.getType();
      String typeName = fieldType.getName();
      System.out.println(fieldName + " " + typeName);
    }

    /**
     * 获取构造函数：java.lang.reflect.Constructor
     * 构造函数也是对象
     * getConstructors() 方法获取所有 public 构造函数
     * getDecleardConstructors() 获取该类自己申明的构造函数
     */
    Constructor[] cs = c.getConstructors();
    for (Constructor constructor: cs) {
      // 获取构造函数名称
      System.out.print("构造函数：" + constructor.getName() + "(");
      // 获取构造函数参数列表
      Class[] paramTypes = constructor.getParameterTypes();
      for (Class c1: paramTypes) {
        System.out.print(c1.getName() + ",");
      }
      System.out.println(")");
    }
  }
}
```

### 0x02 方法的反射

```java
package com.chanshiyu;

import java.lang.reflect.Method;

public class Demo1 {
  public static void main(String[] args) {
    A a = new A();
    Class c = a.getClass();

    // 获取方法 通过名称和参数列表决定
    try {
      // 反射操作调用方法
      // Method m1 = c.getMethod("print", int.class, int.class);
      // m1.invoke(a, 10, 20);

      Method m1 = c.getMethod("print",new Class[]{int.class, int.class});
      m1.invoke(a, new Object[]{10, 20});
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

class A {
  public void print(int a, int b) {
    System.out.println(a + b);
  }

  public void print(String a, String b) {
    System.out.println(a.toUpperCase() + "," + b.toUpperCase());
  }
}
```

### 0x03 泛型的本质

```java
package com.chanshiyu;

import java.lang.reflect.Method;
import java.util.ArrayList;

public class Demo2 {
  public static void main(String[] args) {
    ArrayList list1 = new ArrayList();
    ArrayList<String> list2 = new ArrayList<String>();
    list2.add("hello"); // ok
    // list2.add(20); 错误

    Class c1 = list1.getClass();
    Class c2 = list2.getClass();
    System.out.println(c1 == c2); // true

    /**
     * c1 == c2 返回 true 说明编译之后集合的泛型是去泛型话的
     * Java 中集合的泛型是防止错误输入的，只在编译阶段有效
     * 验证：可以通过方法的反射来绕过编辑阶段检测
     */
    try {
      Method m = c2.getMethod("add", Object.class);
      m.invoke(list2, 20); // 可以添加成功
      System.out.println("list2 length:" + list2.size());
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```
