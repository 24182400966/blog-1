正则表达式一直是我的弱项，工作项目中表单验证又或者平时写写爬虫都是棘手万分，工作中避之不及却又无法割舍，不懂正则真是枉为程序员（羞愧脸），这次找个时间好好补补课。<!-- more -->

## 字符匹配

**正则是匹配模式，要么匹配字符，要么匹配位置**。

### 模糊匹配

除了精确匹配，正则还能实现模糊匹配，模糊匹配又分为横向模糊和纵向模糊。

#### 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。其实现方式是使用量词，譬如 {m, n}，表示连续出现最少 m 次，最多 n 次。

```javascript
const regex = /ab{2,4}c/g
const string = 'abc abbc abbbc abbbbc abbbbbc'
console.log(string.match(regex)) // ["abbc", "abbbc", "abbbbc"]
```

正则 `g` 修饰符表示全局匹配，强调“所有”而不是“第一个”。

```javascript
// 无全局修饰符的情况
const regex = /ab{2,4}c/
const string = 'abc abbc abbbc abbbbc abbbbbc'
console.log(string.match(regex))
// ["abbc", index: 4, input: "abc abbc abbbc abbbbc abbbbbc", groups: undefined]
```

#### 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。其实现方式是使用字符组，譬如 [abc]，表示该字符是可以字符 "a"、"b"、"c" 中的任何一个。

```javascript
const regex = /a[123]b/g
const string = 'a0b a1b a2b a3b a4b'
console.log(string.match(regex)) // ["a1b", "a2b", "a3b"]
```

### 字符组

虽然称为字符组，但匹配的其实只是一个字符。譬如字符组 [abc] 只是匹配一个字符。字符组有范围表示法、排除法和简写形式。

#### 范围表示法

字符组 [0-9a-zA-Z] 表示数字、大小写字母中任意一个字符。

由于连字符"-"有特殊含义，所以要匹配 "a"、"-"、"c" 中的任何一个字符，可以写成如下形式：[-az]、[az-]、[a\-z]，连字符要么开头，要么结尾，要么转义。

#### 排除字符组

排除字符组（反义字符组）[^abc] 表示是一个除 "a"、"b"、"c"之外的任意一个字 符。字符组的第一位放 `^`（脱字符），表示求反。^ 可以配合范围表示法使用，如 [^0-9]。

#### 简写形式

正则简写形式如下：

| 字符组 |                    含义                    |
| :----: | :----------------------------------------: |
|  `\d`  |              [0-9]，表示数字               |
|  `\D`  |             [^0-9]，表示非数字             |
|  `\w`  | [0-9a-zA-Z_]，表示数字、大小写字符和下划线 |
|  `\W`  |       [\^0-9a-zA-Z_]，表示非单词字符       |
|  `\s`  |         [ \t\v\n\r\f]，表示空白符          |
|  `\S`  |        [^ \t\v\n\r\f]，表示非空白符        |
|  `.`   |        [^\n\r\u2028\u2029]，通配符         |

注：[ \t\v\n\r\f] 分别表示空白符、水平制表符、垂直制表符、换行符、回车符、换页符。

通配符 `.` 可以表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。如果想要匹配任意字符，可以使用组合写法：[\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。

### 量词

#### 简写形式

|   量词   |             含义              |
| :------: | :---------------------------: |
| `{m, n}` |      表示出现 m 到 n 次       |
|  `{m,}`  |         至少出现 m 次         |
|  `{m}`   |  等价 {m, m}，表示出现 m 次   |
|   `?`    | 等价 {0, 1}，表示出现或不出现 |
|   `+`    | 等价 {1,}，表示至少出现 1 次  |
|   `*`    |   等价 {0,}，表示出现任意次   |

#### 贪婪匹配与惰性匹配

贪婪匹配会尽可能多的匹配，表现如下：

```javascript
const regex = /\d{2,5}/g
const string = '123 1234 12345 123456'
console.log(string.match(regex))
// ["123", "1234", "12345", "12345"]
```

通过在量词后面加 `?` 实现惰性匹配，惰性匹配会尽可能少的匹配，表现如下：

```javascript
const regex = /\d{2,5}?/g
const string = '123 1234 12345 123456'
console.log(string.match(regex))
// ["12", "12", "34", "12", "34", "12", "34", "56"]
```

### 多选分支

多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 `|`（管道符）分隔，表示其中任何之一。

需要注意的是多选分支是从左到右惰性匹配的，前面匹配成功之后后面的模式便不再尝试。

```javascript
const regex = /good|goodbye/g
const string = 'goodbye'
console.log(string.match(regex))
// ["good"]
```

可以通过更改子模式的顺序来改变匹配的结果。

### 实例应用

#### 匹配文件路径

文件路径格式如 `盘符:\文件夹\文件夹\文件夹\`。

匹配符盘：`[a-zA-Z]:\\`，文件名或文件夹名，不能包含一些特殊字符，需要排除字符组 [^\\:*<>|"?\r\n/] 来表示合法字符，且文件名或文件夹名不能为空，至少有一个字符，需要使用量词 `+`。文件夹可以出现任意次，最后可能是文件而不是文件夹，不需要带 `\\`。

```javascript
const regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/
console.log(regex.test('F:\\study\\regular expression.pdf'))
```

#### 匹配 id

```javascript
const regex = /id=".*"/
const string = '<div id="container" class="main"></div>'
// id="container" class="main"
```

量词 `.` 是通配符，可以匹配双引号，同时是贪婪匹配，所以出错。可以将其改造成惰性匹配：

```javascript
const regex = /id=".*?"/
```

但以上正则匹配效率低，因为其匹配原理设计”回溯“ 概念，最优解如下：

```javascript
const regex = /id="[^"]*"/
```

## 位置匹配

### 位置的概念

位置（锚）是相邻字符之间的位置。可以将位置理解成空字符串。

再 ES5 中，一共有六个锚：`^`、`$`、`\b`、`\B`、`(?=p)`、`(?!p)`。

1. `^` 匹配开头，多行匹配则匹配行开头
2. `&` 匹配结尾，多行匹配则匹配行结尾
3. `\b` 匹配单词边界，即 `\w` 与 `\W`、`^`、`$` 之间的位置
4. `\B` 匹配非单词边界
5. (?=p) 为正向先行断言（positive lookhead），匹配模式 p 前的位置
6. (?!p) 为负向先行断言（negative lookhead）,匹配非 p 前的位置

### 实例应用

#### 数字千分位分隔符

千分位分隔符的插入位置为三位一组数字的前面，且不能是开头位置。

```javascript
const result = '123456789'
const regex = /(?!^)(?=(\d{3})+$)/g
console.log(result.replace(regex, ','))
// 123,456,789
```

#### 密码验证

密码长度 6-12 位，由数字、大小写字母组成，但必须至少包括 2 种字符。

首先考虑匹配 6-12 位的数字、大小写字母：

```javascript
const regex = /^[0-9A-Za-z]{6-12}$/g
```

然后需要判断至少包含两种字符，有两种解法。

**解法一：**

首先判断是否包含数字，正则可以表示如下：

```javascript
const regex = /(?=.*[0-9])^[0-9A-Za-z]{6-12}$/
```

重点需要理解 `(?=.*[0-9])^`，该正则表示开头前的位置，同时也表示开头，因为位置可以表示为空字符串。该正则表示在任意多个字符后有数字。依次类推，如果需要同时包含数组和大写字母可以表示为：

```javascript
const regex = /(?=.*[0-9])(?=.*[A-Z])^[0-9A-Za-z]{6-12}$/
```

最终正则可以表示为：

```javascript
const regex = /((?=.*[0-9])(?=.*[A-Z])|(?=.*[0-9])(?=.*[a-z])|(?=.*[A-Z])(?=.*[a-z]))^[0-9A-Za-z]{6-12}$/

const str1 = '123456'
const str2 = '123456a'
const str3 = 'abcdefgA'
console.log(str1, regex.test(str1)) // false
console.log(str2, regex.test(str2)) // true
console.log(str3, regex.test(str3)) // true
```

**解法二：**

“至少包含两种字符” 表示不能全为数字、大写字母或小写字母，不能全为数字可以表示如下：

```javascript
const regex = /(?!^[0-9]{6-12}$)^[0-9A-Za-z]{6-12}$/
```

所以最终正则可以表示为：

```javascript
const regex = /(?!^[0-9]{6,12}$)(?!^[A-Z]{6,12}$)(?!^[a-z]{6,12}$)^[0-9A-Za-z]{6,12}$/
```

需要注意的是这里没有分支选择 `|`，和解法一不同的是需要同时匹配。

## 括号的作用

## 回溯法原理

## 正则的拆分

## 正则的构建

## 正则编程
