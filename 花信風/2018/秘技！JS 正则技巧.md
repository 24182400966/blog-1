正则表达式一直是我的弱项，工作项目中表单验证又或者平时写写爬虫都是棘手万分，工作中避之不及却又无法割舍，不懂正则真是枉为程序员（羞愧脸），这次找个时间好好补补课。<!-- more -->

## 字符匹配

**正则是匹配模式，要么匹配字符，要么匹配位置**。

### 模糊匹配

除了精确匹配，正则还能实现模糊匹配，模糊匹配又分为横向模糊和纵向模糊。

#### 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。其实现方式是使用量词，譬如 {m, n}，表示连续出现最少 m 次，最多 n 次。

```javascript
const regex = /ab{2,4}c/g
const string = 'abc abbc abbbc abbbbc abbbbbc'
console.log(string.match(regex)) // ["abbc", "abbbc", "abbbbc"]
```

正则 `g` 修饰符表示全局匹配，强调“所有”而不是“第一个”。

```javascript
// 无全局修饰符的情况
const regex = /ab{2,4}c/
const string = 'abc abbc abbbc abbbbc abbbbbc'
console.log(string.match(regex))
// ["abbc", index: 4, input: "abc abbc abbbc abbbbc abbbbbc", groups: undefined]
```

#### 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。其实现方式是使用字符组，譬如 [abc]，表示该字符是可以字符 "a"、"b"、"c" 中的任何一个。

```javascript
const regex = /a[123]b/g
const string = 'a0b a1b a2b a3b a4b'
console.log(string.match(regex)) // ["a1b", "a2b", "a3b"]
```

### 字符组

虽然称为字符组，但匹配的其实只是一个字符。譬如字符组 [abc] 只是匹配一个字符。字符组有范围表示法、排除法和简写形式。

#### 范围表示法

字符组 [0-9a-zA-Z] 表示数字、大小写字母中任意一个字符。

由于连字符"-"有特殊含义，所以要匹配 "a"、"-"、"c" 中的任何一个字符，可以写成如下形式：[-az]、[az-]、[a\-z]，连字符要么开头，要么结尾，要么转义。

#### 排除字符组

排除字符组（反义字符组）[^abc] 表示是一个除 "a"、"b"、"c"之外的任意一个字 符。字符组的第一位放 `^`（脱字符），表示求反。^ 可以配合范围表示法使用，如 [^0-9]。

#### 简写形式

正则简写形式如下：

| 字符组 |                    含义                    |
| :----: | :----------------------------------------: |
|   \d   |              [0-9]，表示数字               |
|   \D   |             [^0-9]，表示非数字             |
|   \w   | [0-9a-zA-Z_]，表示数字、大小写字符和下划线 |
|   \W   |       [\^0-9a-zA-Z_]，表示非单词字符       |
|   \s   |         [ \t\v\n\r\f]，表示空白符          |
|   \S   |        [^ \t\v\n\r\f]，表示非空白符        |
|   .    |        [^\n\r\u2028\u2029]，通配符         |

注：[ \t\v\n\r\f] 分别表示空白符、水平制表符、垂直制表符、换行符、回车符、换页符。

通配符 `.` 可以表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。如果想要匹配任意字符，可以使用组合写法：[\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。

### 量词

#### 简写形式

|  量词  |             含义              |
| :----: | :---------------------------: |
| {m, n} |      表示出现 m 到 n 次       |
|  {m,}  |         至少出现 m 次         |
|  {m}   |  等价 {m, m}，表示出现 m 次   |
|   ?    | 等价 {0, 1}，表示出现或不出现 |
|   +    | 等价 {1,}，表示至少出现 1 次  |
|   \*   |   等价 {0,}，表示出现任意次   |

#### 贪婪匹配与惰性匹配

贪婪匹配会尽可能多的匹配，表现如下：

```javascript
const regex = /\d{2,5}/g
const string = '123 1234 12345 123456'
console.log(string.match(regex))
// ["123", "1234", "12345", "12345"]
```

通过在量词后面加 `?` 实现惰性匹配，惰性匹配会尽可能少的匹配，表现如下：

```javascript
const regex = /\d{2,5}?/g
const string = '123 1234 12345 123456'
console.log(string.match(regex))
// ["12", "12", "34", "12", "34", "12", "34", "56"]
```

### 多选分支

多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 `|`（管道符）分隔，表示其中任何之一。

需要注意的是多选分支是从左到右惰性匹配的，前面匹配成功之后后面的模式便不再尝试。

```javascript
const regex = /good|goodbye/g
const string = 'goodbye'
console.log(string.match(regex))
// ["good"]
```

可以通过更改子模式的顺序来改变匹配的结果。

## 位置匹配

## 括号的作用

## 回溯法原理

## 正则的拆分

## 正则的构建

## 正则编程


(2[0-3]|[])[0-5][0-9]